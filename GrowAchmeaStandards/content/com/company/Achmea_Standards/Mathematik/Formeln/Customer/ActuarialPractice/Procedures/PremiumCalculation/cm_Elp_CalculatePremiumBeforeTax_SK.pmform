<?xml version="1.0" encoding="UTF-8"?>
<pm:formula xmlns:pm="http://www.msg.de/msgpm/data/2011" abstract="false" datatype="float" dataversion="2012" final="false" guid="ZZZPM3FORM0000005GF0000AZZ" isnullable="false" nrdims="0" pmid="5GF0000AZZ" sealed="false" sortkey="0" visibility="content">
  <pm:namespace>com::company::Achmea_Standards::Mathematik::Formeln::Customer::ActuarialPractice::Procedures::PremiumCalculation</pm:namespace>
  <pm:name>cm_Elp_CalculatePremiumBeforeTax_SK</pm:name>
  <pm:notice encoding="none"><![CDATA[Description:
Calculates the premium before tax by adding up the market premium and commission costs.
The market premium itself is the sum of PreDiscountPremium and Proposition Discount. 
The commission costs are calculated by multiplying the looked up commission factor with the market premium.

Result:
float

Input parameters:
 sRatingCodeProd Rating Code of the product which has to be looked up
]]></pm:notice>
  <pm:resultname>Res</pm:resultname>
  <pm:compileroptions>
    <pm:languageoptions>
      <pm:m10options autobreaksincases="false" forceassignmenttargetresizing="false">
        <pm:validationseverities arrayassignmentswithoutresize="warning" assignmentsinconditions="warning" deprecatedfeatures="ignore" implicitlydeclaredmembers="error" missingsemicolons="ignore" multipleresultassignments="warning" unusedsymbols="warning"/>
      </pm:m10options>
    </pm:languageoptions>
  </pm:compileroptions>
  <pm:sourcecode language="m10">
    <pm:text encoding="none"><![CDATA[#import "incStdMethods_ACHMEA.h"

//Externe Pfade

//Externe Objekte
extern object extBtr
extern object extProd

//Versicherungstechnische Methoden

//Attributes for PremiumBeforeTaxWithoutDiscount calculation
data int CalcPremBeforeTaxWithoutDiscount
data float PremiumBeforeTaxWithoutDiscount
data float DiscountBasePremium

//Attribute Merkmale
data int Zahlungsrhythmus

//data float Tarifbeitrag2_jaehrlich
data float ZahlbeitragVorSteuern
data float Zahlbeitrag
data float BruttoBeitrag
data float JahresBruttoBeitrag
data float JahresZahlbeitragVorSteuern
data float PropositionPremium
data float DauerFaktor
data float Commission
data float CommissionInputPercentage
data float CommissionInputAmount
data float FixedCommissionAmount

//interne Variablen
int li_Zahlungsrhythmus
float lf_Zahlungsrhythmus_skaliert
float lf_JahresZahlbeitragVorSteuern
float lf_ZahlbeitragVorSteuern
float lf_PropositionPremium 
float lf_PremiumBeforeTax
float lf_Commission
float lf_CommissionInputAmount
float lf_FixedCommissionAmount 

float lf_CommissionDiscountBasePremium
float lf_DiscountBasePremium
float lf_PremiumBeforeTaxWithoutDiscount

/*********************************************************************/
/* Processing                                                      */
/*********************************************************************/

li_Zahlungsrhythmus = extBtr.Zahlungsrhythmus

//One-Time Payment is scaled with the duration of the one-time payment if(li_Zahlungsrhythmus == 0)
/* Currently not needed, no requirements for one time premium
/* If needed, be aware to match payment frequency, this formula is based on yearly figures.*/
if(li_Zahlungsrhythmus == 0)
{
	lf_Zahlungsrhythmus_skaliert = 1/extBtr.DauerFaktor
}
else
{
	lf_Zahlungsrhythmus_skaliert = li_Zahlungsrhythmus
}


//Get the PropositionPremium
lf_PropositionPremium = extBtr.PropositionPremium
lf_DiscountBasePremium = extBtr.DiscountBasePremium

//Calculate commission
if (iMaxCommission == false) 
{
	lf_CommissionInputAmount = extBtr.CommissionInputAmount * ( 12 / lf_Zahlungsrhythmus_skaliert )
	lf_Commission = rnd( lf_PropositionPremium * (extBtr.CommissionInputPercentage/100) + lf_CommissionInputAmount,2)
	
	if ( extProd.CalcPremBeforeTaxWithoutDiscount == 1 ) 
	{
		lf_CommissionDiscountBasePremium = rnd( lf_DiscountBasePremium * (extBtr.CommissionInputPercentage/100) + lf_CommissionInputAmount,2)
		lf_PremiumBeforeTaxWithoutDiscount = lf_DiscountBasePremium + lf_CommissionDiscountBasePremium
	}
}
else
{
	lf_FixedCommissionAmount = this.FixedCommissionAmount * ( 12 / lf_Zahlungsrhythmus_skaliert )
	lf_Commission = rnd( lf_FixedCommissionAmount,2)
	
	if ( extProd.CalcPremBeforeTaxWithoutDiscount == 1 ) 
	{
		lf_CommissionDiscountBasePremium = rnd( lf_FixedCommissionAmount,2)
		lf_PremiumBeforeTaxWithoutDiscount = lf_DiscountBasePremium + lf_CommissionDiscountBasePremium
	}
}

// Set the PremiumBeforeTax 
lf_PremiumBeforeTax = lf_PropositionPremium + lf_Commission

/* Fill the Standard Field JahresZahlbeitragVorSteuern */
lf_JahresZahlbeitragVorSteuern = lf_PremiumBeforeTax * lf_Zahlungsrhythmus_skaliert
extBtr.JahresZahlbeitragVorSteuern = lf_JahresZahlbeitragVorSteuern

/* Set Gross Premium based on yearly payment frequency */
extBtr.JahresBruttoBeitrag = extBtr.JahresZahlbeitragVorSteuern

/* Calculate Zahlbeitrag based on payment frequency */
lf_ZahlbeitragVorSteuern = lf_PremiumBeforeTax

extBtr.ZahlbeitragVorSteuern = lf_ZahlbeitragVorSteuern
extBtr.PremiumBeforeTaxWithoutDiscount = lf_PremiumBeforeTaxWithoutDiscount

/* Set Zahlbeitrag, if tax will be calulated, they will be added in Berechne_Steuern */
extBtr.Zahlbeitrag = lf_ZahlbeitragVorSteuern

/* Bruttobeitrag setzen */
extBtr.BruttoBeitrag = extBtr.ZahlbeitragVorSteuern

// Save Components	
extBtr.Commission = lf_Commission

Res = RC_OK

#import "incStdMethodsBottom_ACHMEA.h"]]></pm:text>
  </pm:sourcecode>
</pm:formula>
